// ðŸ¦• AUTOGENERATED! DO NOT EDIT! File to edit: notebooks.ipynb

import path from "node:path";
import { z } from "zod";
const cellOutputDataSchema = z.object({
  "text/markdown": z.array(z.string()).optional(),
  "text/plain": z.array(z.string()).optional(),
});

const cellOutputSchema = z.object({
  text: z.array(z.string()).optional(),
  data: cellOutputDataSchema.optional(),
});

const cellSchema = z.object({
  cell_type: z.enum(["code", "markdown"]),
  source: z.array(z.string()),
  outputs: z.array(cellOutputSchema).optional(),
});
const nbSchema = z.object({ filename: z.string(), cells: z.array(cellSchema) });

export type Cell = z.infer<typeof cellSchema>;
export type Nb = z.infer<typeof nbSchema>;

export const loadNb = async (nbPath: string): Promise<Nb> =>
  nbSchema.parse(
    Object.assign(
      { filename: nbPath },
      JSON.parse(await Deno.readTextFile(nbPath)),
    ),
  );
export const getNbTitle = (nb: Nb): string => {
  const mds = nb.cells.length > 0 && nb.cells[0].cell_type === "markdown"
    ? nb.cells[0].source
    : null;
  const md = mds && mds.length > 0 && mds[0].trim().startsWith("# ")
    ? mds[0]
    : null;
  return md
    ? md.replace(/^# /, "").replaceAll("\n", "").trim()
    : path.basename(nb.filename);
};
export const getCellOutput = (cell: Cell): string => {
  let result = "";
  if (!cell.outputs) return result;
  for (const output of cell.outputs) {
    if (output.text) {
      result += output.text.join("\n");
    }
    if (output.data) {
      const c = output.data["text/markdown"] || output.data["text/plain"] || [];
      for (const line of c) {
        result += line;
      }
    }
  }
  return result;
};
