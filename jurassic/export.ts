import path from "node:path";
import { isDirective, loadNb } from "jurassic/notebooks.ts";
import {
  getNotebooksToProcess,
  removeDuplicateImports,
} from "jurassic/utils.ts";
import type { Config } from "jurassic/config.ts";
import { getConfig } from "jurassic/config.ts";
// ðŸ¦• AUTOGENERATED! DO NOT EDIT! File to edit: export.ipynb

const moduleHeader = (moduleName: string): string =>
  `// ðŸ¦• AUTOGENERATED! DO NOT EDIT! File to edit: ${moduleName}\n\n`;

const processNb = async (
  nbPath: string,
  moduleName: string,
): Promise<string[]> => {
  const nb = await loadNb(nbPath);
  // we only need exportable cells
  const exportCells = nb.cells.filter((cell) => cell.isExportable);
  const testCells = nb.cells.filter((cell) => cell.isTestCell);
  return [
    removeDuplicateImports(
      exportCells.reduce(
        // get rid of directives, we want code only
        (acc, cell) =>
          acc + cell.source.filter((s) => !isDirective(s)).join(""),
        moduleHeader(moduleName),
      ),
    ),
    testCells.length !== 0
      ? removeDuplicateImports(
        testCells.reduce(
          (acc, cell) => acc + cell.source.join(""),
          moduleHeader(moduleName),
        ),
      )
      : "",
  ];
};

export const exportNb = async (
  notebookPath?: string | undefined,
  config?: Config | undefined,
): Promise<void> => {
  notebookPath = notebookPath || ".";
  config = config || await getConfig();
  const notebooksToProcess: string[] = getNotebooksToProcess(
    notebookPath,
    config.nbsPath,
  );

  try {
    await Deno.stat(config.outputPath);
    await Deno.remove(config.outputPath, { recursive: true });
  } catch {
    // noop
  }

  // let's go through all notebooks and process them one by one
  for (const notebook of notebooksToProcess) {
    // output module is the same as the input notebook, but with .ts extension
    const outputFile = notebook.replace(".ipynb", ".ts");
    // make sure we preserve subdirectories if any
    const outputDir = path.join(config.outputPath, path.dirname(outputFile));
    await Deno.mkdir(outputDir, { recursive: true });

    const [moduleCode, testCode] = await processNb(
      path.resolve(config.nbsPath, notebook),
      notebook,
    );

    await Deno.writeTextFile(
      path.join(config.outputPath, outputFile),
      moduleCode,
    );
    if (testCode) {
      await Deno.writeTextFile(
        path.join(config.outputPath, outputFile.replace(".ts", ".test.ts")),
        [moduleCode, "/** ----------------tests ---------------- **/", testCode]
          .join("\n\n"),
      );
    }
  }
};
