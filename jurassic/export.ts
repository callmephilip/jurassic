// ðŸ¦• AUTOGENERATED! DO NOT EDIT! File to edit: export.ipynb

import path from "node:path";
import { loadNb } from "jurassic/notebooks.ts";
import type { Config } from "jurassic/config.ts";
import type { Cell } from "jurassic/notebooks.ts";
const isDirective = (ln: string): boolean =>
  ln.replaceAll(" ", "").startsWith("//|");
const isCellExportable = (cell: Cell): boolean =>
  cell.cell_type === "code" &&
  cell.source.length > 0 &&
  isDirective(cell.source[0]) &&
  cell.source[0].includes("export");
const moduleHeader = (moduleName: string): string =>
  `// ðŸ¦• AUTOGENERATED! DO NOT EDIT! File to edit: ${moduleName}\n\n`;

const processNb = async (
  nbPath: string,
  moduleName: string,
): Promise<string> => {
  const nb = await loadNb(nbPath);
  // we only need exportable cells
  const exportCells = nb.cells.filter((cell) => isCellExportable(cell));
  return exportCells.reduce(
    // get rid of directives, we want code only
    (acc, cell) => acc + cell.source.filter((s) => !isDirective(s)).join(""),
    moduleHeader(moduleName),
  );
};
export const exportNb = async (
  notebookPath: string,
  config: Config,
): Promise<void> => {
  const fullPath = path.join(config.nbsPath, notebookPath);
  const fileInfo = await Deno.stat(fullPath);
  const notebooksToProcess: string[] = [];

  if (fileInfo.isDirectory) {
    // if target is a directory, let's go through all files/directories inside
    for await (const file of await Deno.readDir(fullPath)) {
      if (file.isDirectory) {
        // got another directory? delegate to another exportNb
        await exportNb(path.join(notebookPath, file.name), config);
        continue;
      }

      // we are only interested in notebooks
      if (!file.name.endsWith(".ipynb")) continue;

      // relative path only, puhleeze
      notebooksToProcess.push(
        path.relative(config.nbsPath, path.join(fullPath, file.name)),
      );
    }
  }

  // let's go through all notebooks and process them one by one
  for (const notebook of notebooksToProcess) {
    // output module is the same as the input notebook, but with .ts extension
    const outputFile = notebook.replace(".ipynb", ".ts");
    // make sure we preserve subdirectories if any
    const outputDir = path.join(config.outputPath, path.dirname(outputFile));
    await Deno.mkdir(outputDir, { recursive: true });
    await Deno.writeTextFile(
      path.join(config.outputPath, outputFile),
      await processNb(path.resolve(config.nbsPath, notebook), notebook),
    );
  }
};
// create markdown representation of the directory listing files and subdirectories
export const dirListing = async (dir: string, d = 0): Promise<string> => {
  if (d > 10) {
    return "";
  }

  let md = "";
  for await (const f of Deno.readDir(dir)) {
    md += `${"  ".repeat(d)}- ${f.name}\n`;
    if (f.isDirectory) {
      md += await dirListing(path.join(dir, f.name), d + 1);
    }
  }
  return md;
};
